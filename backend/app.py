import os
import uuid
import json
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse, JSONResponse
from sqlalchemy.orm import Session
from sqlalchemy import select, desc
from dotenv import load_dotenv
import google.generativeai as genai
from typing import List, Optional
from datetime import datetime, timedelta
from pydantic import BaseModel

from database import SessionLocal, Conversation
from models import ChatRequest, ChatMessage
from utils.token_counter import count_tokens
from agents import AgentRouter, KnowledgeAgent, MathAgent

load_dotenv()

app = FastAPI()
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))

app.add_middleware(
    CORSMiddleware, 
    allow_origins=["http://localhost:3000", "http://127.0.0.1:3000", "http://192.168.1.67:3000"],
    allow_credentials=True, 
    allow_methods=["*"], 
    allow_headers=["*"],
)

agent_router = AgentRouter()

# Challenge-specific request/response models
class ChallengeRequest(BaseModel):
    message: str
    user_id: str
    conversation_id: str

class AgentWorkflow(BaseModel):
    agent: str
    decision: str

class ChallengeResponse(BaseModel):
    response: str
    source_agent_response: str
    agent_workflow: List[AgentWorkflow]

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.post("/chat", response_model=ChallengeResponse)
async def chat_challenge_format(request: ChallengeRequest, db: Session = Depends(get_db)):
    """
    Challenge-compliant chat endpoint with exact response format
    """
    session_id = request.conversation_id
    user_message = request.message
    user_id = request.user_id
    
    # Save user message
    db_user_msg = Conversation(
        session_id=session_id, 
        role="user", 
        content=user_message,
        tokens=count_tokens(user_message), 
        cost=0,
        agent_used=None,
        execution_time=None,
        source=None
    )
    db.add(db_user_msg)
    db.commit()
    
    try:
        # Route the query with logging
        agent_type, router_log = agent_router.classify_query(user_message)
        
        # Select and execute appropriate agent
        if agent_type == "math":
            agent = MathAgent()
            agent_name = "MathAgent"
        else:
            agent = KnowledgeAgent()
            agent_name = "KnowledgeAgent"
        
        # Process the query
        full_response, agent_log = agent.process(user_message, session_id)
        
        # Save assistant message with logging details
        assistant_tokens = count_tokens(full_response)
        
        exec_time = None
        if 'execution_time' in agent_log.get('metrics', {}):
            exec_time_str = agent_log['metrics']['total_execution_time']
            exec_time = float(exec_time_str.replace('s', ''))
        
        db_assistant_msg = Conversation(
            session_id=session_id, 
            role='assistant', 
            content=full_response,
            tokens=assistant_tokens, 
            cost=0,
            agent_used=agent_type,
            execution_time=exec_time,
            source=agent_log.get('source'),
            router_decision=router_log,
            agent_log=agent_log
        )
        db.add(db_assistant_msg)
        db.commit()
        
        # Build challenge-compliant response
        workflow = []
        
        # Add RouterAgent decision
        workflow.append(AgentWorkflow(
            agent="RouterAgent",
            decision=agent_name
        ))
        
        # Add the executing agent
        workflow.append(AgentWorkflow(
            agent=agent_name,
            decision=""  # The actual agent doesn't make a decision, it provides the answer
        ))
        
        # Create the response in the exact format required
        response = ChallengeResponse(
            response=full_response,
            source_agent_response=f"Text generated by the specialized agent.",
            agent_workflow=workflow
        )
        
        return response
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/chat")
async def chat_streaming(request: ChatRequest, db: Session = Depends(get_db)):
    """
    Original streaming chat endpoint for the frontend
    """
    session_id = request.session_id or str(uuid.uuid4())
    user_message = request.messages[-1]

    # Save user message
    db_user_msg = Conversation(
        session_id=session_id, 
        role=user_message.role, 
        content=user_message.content,
        tokens=count_tokens(user_message.content), 
        cost=0,
        agent_used=None,
        execution_time=None,
        source=None
    )
    db.add(db_user_msg)
    db.commit()

    try:
        def generate():
            # Route the query with logging
            agent_type, router_log = agent_router.classify_query(user_message.content)
            
            # Select and execute appropriate agent
            if agent_type == "math":
                agent = MathAgent()
            else:
                agent = KnowledgeAgent()
            
            full_response, agent_log = agent.process(user_message.content, session_id)
            
            # Send response to client
            yield f"data: {json.dumps({'content': full_response, 'session_id': session_id})}\n\n"
            
            # Save assistant message with logging details
            assistant_tokens = count_tokens(full_response)
            
            exec_time = None
            if 'execution_time' in agent_log.get('metrics', {}):
                exec_time_str = agent_log['metrics']['total_execution_time']
                exec_time = float(exec_time_str.replace('s', ''))
            
            db_assistant_msg = Conversation(
                session_id=session_id, 
                role='assistant', 
                content=full_response,
                tokens=assistant_tokens, 
                cost=0,
                agent_used=agent_type,
                execution_time=exec_time,
                source=agent_log.get('source'),
                router_decision=router_log,
                agent_log=agent_log
            )
            db.add(db_assistant_msg)
            db.commit()
            
            yield "data: [DONE]\n\n"
        
        return StreamingResponse(generate(), media_type="text/event-stream")
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/history/{session_id}")
async def get_history(session_id: str, db: Session = Depends(get_db)):
    """Get conversation history with enhanced logging details"""
    try:
        stmt = select(Conversation).where(
            Conversation.session_id == session_id
        ).order_by(Conversation.created_at)
        
        conversations = db.execute(stmt).scalars().all()
        
        return {
            "session_id": session_id,
            "messages": [
                {
                    "role": conv.role,
                    "content": conv.content,
                    "timestamp": conv.created_at.isoformat(),
                    "tokens": conv.tokens,
                    "agent_used": conv.agent_used,
                    "execution_time": conv.execution_time,
                    "source": conv.source,
                    "router_decision": conv.router_decision,
                    "agent_log": conv.agent_log
                }
                for conv in conversations
            ]
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/sessions")
async def get_all_sessions(db: Session = Depends(get_db)):
    """Get all unique session IDs with their latest activity"""
    try:
        # Get unique sessions with latest activity
        sessions = db.query(
            Conversation.session_id,
            Conversation.created_at,
            Conversation.content
        ).distinct(Conversation.session_id).order_by(
            Conversation.session_id, 
            desc(Conversation.created_at)
        ).all()
        
        return {
            "sessions": [
                {
                    "session_id": session[0],
                    "last_activity": session[1].isoformat() if session[1] else None,
                    "last_message_preview": session[2][:100] if session[2] else None
                }
                for session in sessions
            ],
            "total_sessions": len(sessions)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/analytics")
async def get_analytics(db: Session = Depends(get_db)):
    """Get analytics about agent usage and performance"""
    try:
        # Get all assistant messages with agent data
        assistant_msgs = db.query(Conversation).filter(
            Conversation.role == 'assistant',
            Conversation.agent_used.isnot(None)
        ).all()
        
        if not assistant_msgs:
            return {
                "message": "No agent interactions yet",
                "total_interactions": 0
            }
        
        # Calculate statistics
        math_count = sum(1 for m in assistant_msgs if m.agent_used == 'math')
        knowledge_count = sum(1 for m in assistant_msgs if m.agent_used == 'knowledge')
        
        math_times = [m.execution_time for m in assistant_msgs 
                     if m.agent_used == 'math' and m.execution_time]
        knowledge_times = [m.execution_time for m in assistant_msgs 
                          if m.agent_used == 'knowledge' and m.execution_time]
        
        return {
            "total_interactions": len(assistant_msgs),
            "agent_usage": {
                "math": math_count,
                "knowledge": knowledge_count
            },
            "average_execution_time": {
                "math": sum(math_times) / len(math_times) if math_times else 0,
                "knowledge": sum(knowledge_times) / len(knowledge_times) if knowledge_times else 0
            },
            "total_tokens_used": sum(m.tokens for m in assistant_msgs if m.tokens),
            "recent_queries": [
                {
                    "timestamp": m.created_at.isoformat(),
                    "agent": m.agent_used,
                    "execution_time": m.execution_time,
                    "tokens": m.tokens
                }
                for m in assistant_msgs[-10:]  # Last 10 interactions
            ]
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/logs/recent")
async def get_recent_logs(
    limit: int = 20,
    agent_type: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """Get recent logs with optional filtering by agent type"""
    try:
        query = db.query(Conversation).filter(
            Conversation.role == 'assistant',
            Conversation.agent_log.isnot(None)
        )
        
        if agent_type:
            query = query.filter(Conversation.agent_used == agent_type)
        
        logs = query.order_by(desc(Conversation.created_at)).limit(limit).all()
        
        return {
            "logs": [
                {
                    "id": log.id,
                    "session_id": log.session_id,
                    "timestamp": log.created_at.isoformat(),
                    "agent": log.agent_used,
                    "execution_time": log.execution_time,
                    "source": log.source,
                    "router_decision": log.router_decision,
                    "agent_log": log.agent_log,
                    "content_preview": log.content[:100] + "..." if len(log.content) > 100 else log.content
                }
                for log in logs
            ],
            "total": len(logs)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))