import os
import uuid
import json
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse, JSONResponse
from sqlalchemy.orm import Session
from sqlalchemy import select, desc
from dotenv import load_dotenv
import google.generativeai as genai
from typing import List, Optional
from datetime import datetime, timedelta, timezone
from pydantic import BaseModel, ValidationError

from database import SessionLocal, Conversation
from models import ChatRequest, ChatMessage, ChallengeRequest, ChallengeResponse, AgentWorkflow
from utils.token_counter import count_tokens
from agents import AgentRouter, KnowledgeAgent, MathAgent
from validators import ChallengeRequestValidator, QueryValidator, ResponseValidator
from constants import APIConfig, QueryLimits, ResponseLimits, DatabaseConfig, ErrorMessages
from redis_client import redis_client

load_dotenv()

app = FastAPI(title="CloudWalk AI Chat API", version="1.0.0")
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))

app.add_middleware(
    CORSMiddleware, 
    allow_origins=APIConfig.CORS_ORIGINS,
    allow_credentials=True, 
    allow_methods=["*"], 
    allow_headers=["*"],
)

agent_router = AgentRouter()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.post("/chat", response_model=ChallengeResponse)
async def chat_challenge_format(request: ChallengeRequest, db: Session = Depends(get_db)):
    """Challenge-compliant chat endpoint with validation."""
    
    try:
        validated_request = ChallengeRequestValidator(
            message=request.message,
            user_id=request.user_id,
            conversation_id=request.conversation_id
        )
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=e.errors())
    
    session_id = validated_request.conversation_id
    user_message = QueryValidator.sanitize_query(validated_request.message)
    user_id = validated_request.user_id
    
    if len(user_message) > QueryLimits.MAX_QUERY_LENGTH:
        raise HTTPException(status_code=400, detail=f"Message too long (max {QueryLimits.MAX_QUERY_LENGTH} characters)")
    
    if not QueryValidator.check_prompt_injection(user_message):
        raise HTTPException(status_code=400, detail="Suspicious input detected")
    
    db_user_msg = Conversation(
        session_id=session_id, 
        role="user", 
        content=user_message,
        tokens=count_tokens(user_message), 
        cost=0,
        agent_used=None,
        execution_time=None,
        source=None
    )
    db.add(db_user_msg)
    db.commit()

    # Store in Redis for fast access
    redis_client.store_conversation(session_id, {
        "role": "user",
        "content": user_message,
        "timestamp": datetime.now(timezone.utc).isoformat()
    })

    try:
        agent_type, router_log = agent_router.classify_query(user_message, user_id, session_id)
        
        if agent_type == "math":
            agent = MathAgent()
            agent_name = "MathAgent"
        else:
            agent = KnowledgeAgent()
            agent_name = "KnowledgeAgent"
        
        full_response, agent_log = agent.process(user_message, session_id, user_id)
        
        full_response = ResponseValidator.validate_response(full_response)
        
        assistant_tokens = count_tokens(full_response)
        
        exec_time = None
        if 'metrics' in agent_log and 'total_execution_time' in agent_log['metrics']:
            exec_time_str = agent_log['metrics']['total_execution_time']
            exec_time = float(exec_time_str.replace('s', ''))
        
        source_info = "Text generated by the specialized agent."
        if agent_type == "knowledge" and 'source' in agent_log:
            if agent_log['source'] and 'chunks_retrieved' in agent_log['source']:
                source_info = f"Retrieved from knowledge base: {agent_log['source']['chunks_retrieved']} chunks"
        
        db_assistant_msg = Conversation(
            session_id=session_id, 
            role='assistant', 
            content=full_response,
            tokens=assistant_tokens, 
            cost=0,
            agent_used=agent_type,
            execution_time=exec_time,
            source=json.dumps(agent_log.get('source')) if agent_log.get('source') else None,
            router_decision=json.dumps(router_log) if router_log else None,
            agent_log=json.dumps(agent_log) if agent_log else None
        )
        db.add(db_assistant_msg)
        db.commit()

        # Store assistant response in Redis
        redis_client.store_conversation(session_id, {
            "role": "assistant",
            "content": full_response,
            "agent": agent_type,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
        
        workflow = [
            AgentWorkflow(agent="RouterAgent", decision=agent_name),
            AgentWorkflow(agent=agent_name, decision="")
        ]
        
        if not ResponseValidator.validate_workflow([w.dict() for w in workflow]):
            raise ValueError("Invalid workflow structure")
        
        response = ChallengeResponse(
            response=full_response,
            source_agent_response=source_info,
            agent_workflow=workflow
        )
        
        return response
        
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=ErrorMessages.GENERIC_ERROR)

@app.post("/api/chat")
async def chat_streaming(request: ChatRequest, db: Session = Depends(get_db)):
    """Streaming chat endpoint with validation."""
    
    session_id = request.session_id or str(uuid.uuid4())
    
    if not QueryValidator.validate_session_id(session_id):
        session_id = str(uuid.uuid4())
    
    user_message = request.messages[-1]
    sanitized_content = QueryValidator.sanitize_query(user_message.content)
    
    if not QueryValidator.check_prompt_injection(sanitized_content):
        raise HTTPException(status_code=400, detail="Suspicious input detected")

    db_user_msg = Conversation(
        session_id=session_id, 
        role=user_message.role, 
        content=sanitized_content,
        tokens=count_tokens(sanitized_content), 
        cost=0,
        agent_used=None,
        execution_time=None,
        source=None
    )
    db.add(db_user_msg)
    db.commit()

    try:
        def generate():
            agent_type, router_log = agent_router.classify_query(sanitized_content)
            
            if agent_type == "math":
                agent = MathAgent()
            else:
                agent = KnowledgeAgent()
            
            full_response, agent_log = agent.process(sanitized_content, session_id)
            full_response = ResponseValidator.validate_response(full_response)
            
            yield f"data: {json.dumps({'content': full_response, 'session_id': session_id})}\n\n"
            
            assistant_tokens = count_tokens(full_response)
            
            exec_time = None
            if 'metrics' in agent_log and 'total_execution_time' in agent_log['metrics']:
                exec_time_str = agent_log['metrics']['total_execution_time']
                exec_time = float(exec_time_str.replace('s', ''))
            
            db_assistant_msg = Conversation(
                session_id=session_id, 
                role='assistant', 
                content=full_response,
                tokens=assistant_tokens, 
                cost=0,
                agent_used=agent_type,
                execution_time=exec_time,
                source=json.dumps(agent_log.get('source')) if agent_log.get('source') else None,
                router_decision=json.dumps(router_log) if router_log else None,
                agent_log=json.dumps(agent_log) if agent_log else None
            )
            db.add(db_assistant_msg)
            db.commit()
            
            yield "data: [DONE]\n\n"
        
        return StreamingResponse(generate(), media_type="text/event-stream")
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=ErrorMessages.GENERIC_ERROR)

@app.get("/api/history/{session_id}")
async def get_history(session_id: str, db: Session = Depends(get_db)):
    """Get conversation history with validation."""
    
    if not QueryValidator.validate_session_id(session_id):
        raise HTTPException(status_code=400, detail=ErrorMessages.INVALID_REQUEST)
    
    try:
        stmt = select(Conversation).where(
            Conversation.session_id == session_id
        ).order_by(Conversation.created_at).limit(DatabaseConfig.MAX_QUERY_RESULTS)
        
        conversations = db.execute(stmt).scalars().all()
        
        if not conversations:
            raise HTTPException(status_code=404, detail=ErrorMessages.SESSION_NOT_FOUND)
        
        return {
            "session_id": session_id,
            "messages": [
                {
                    "role": conv.role,
                    "content": conv.content,
                    "timestamp": conv.created_at.isoformat(),
                    "tokens": conv.tokens,
                    "agent_used": conv.agent_used,
                    "execution_time": conv.execution_time,
                    "source": json.loads(conv.source) if conv.source else None,
                    "router_decision": json.loads(conv.router_decision) if conv.router_decision else None,
                    "agent_log": json.loads(conv.agent_log) if conv.agent_log else None
                }
                for conv in conversations
            ]
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=ErrorMessages.GENERIC_ERROR)

@app.get("/api/sessions")
async def get_all_sessions(db: Session = Depends(get_db)):
    """Get all unique session IDs with their latest activity."""
    try:
        sessions = db.query(
            Conversation.session_id,
            Conversation.created_at,
            Conversation.content
        ).distinct(Conversation.session_id).order_by(
            Conversation.session_id, 
            desc(Conversation.created_at)
        ).limit(DatabaseConfig.MAX_QUERY_RESULTS).all()
        
        return {
            "sessions": [
                {
                    "session_id": session[0],
                    "last_activity": session[1].isoformat() if session[1] else None,
                    "last_message_preview": session[2][:DatabaseConfig.SESSION_PREVIEW_LENGTH] if session[2] else None
                }
                for session in sessions
            ],
            "total_sessions": len(sessions)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=ErrorMessages.GENERIC_ERROR)

@app.get("/api/analytics")
async def get_analytics(db: Session = Depends(get_db)):
    """Get analytics about agent usage and performance."""
    try:
        assistant_msgs = db.query(Conversation).filter(
            Conversation.role == 'assistant',
            Conversation.agent_used.isnot(None)
        ).limit(DatabaseConfig.MAX_QUERY_RESULTS).all()
        
        if not assistant_msgs:
            return {
                "message": "No agent interactions yet",
                "total_interactions": 0
            }
        
        math_count = sum(1 for m in assistant_msgs if m.agent_used == 'math')
        knowledge_count = sum(1 for m in assistant_msgs if m.agent_used == 'knowledge')
        
        math_times = [m.execution_time for m in assistant_msgs 
                     if m.agent_used == 'math' and m.execution_time]
        knowledge_times = [m.execution_time for m in assistant_msgs 
                          if m.agent_used == 'knowledge' and m.execution_time]
        
        return {
            "total_interactions": len(assistant_msgs),
            "agent_usage": {
                "math": math_count,
                "knowledge": knowledge_count
            },
            "average_execution_time": {
                "math": sum(math_times) / len(math_times) if math_times else 0,
                "knowledge": sum(knowledge_times) / len(knowledge_times) if knowledge_times else 0
            },
            "total_tokens_used": sum(m.tokens for m in assistant_msgs if m.tokens),
            "recent_queries": [
                {
                    "timestamp": m.created_at.isoformat(),
                    "agent": m.agent_used,
                    "execution_time": m.execution_time,
                    "tokens": m.tokens
                }
                for m in assistant_msgs[-10:]
            ]
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=ErrorMessages.GENERIC_ERROR)

@app.get("/api/logs/recent")
async def get_recent_logs(
    limit: int = DatabaseConfig.RECENT_LOGS_DEFAULT_LIMIT,
    agent_type: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """Get recent logs with optional filtering by agent type."""
    
    if limit > DatabaseConfig.MAX_QUERY_RESULTS:
        limit = DatabaseConfig.MAX_QUERY_RESULTS
    
    try:
        query = db.query(Conversation).filter(
            Conversation.role == 'assistant',
            Conversation.agent_log.isnot(None)
        )
        
        if agent_type and agent_type in ['math', 'knowledge']:
            query = query.filter(Conversation.agent_used == agent_type)
        
        logs = query.order_by(desc(Conversation.created_at)).limit(limit).all()
        
        return {
            "logs": [
                {
                    "id": log.id,
                    "session_id": log.session_id,
                    "timestamp": log.created_at.isoformat(),
                    "agent": log.agent_used,
                    "execution_time": log.execution_time,
                    "source": json.loads(log.source) if log.source else None,
                    "router_decision": json.loads(log.router_decision) if log.router_decision else None,
                    "agent_log": json.loads(log.agent_log) if log.agent_log else None,
                    "content_preview": log.content[:DatabaseConfig.SESSION_PREVIEW_LENGTH] + "..." if len(log.content) > DatabaseConfig.SESSION_PREVIEW_LENGTH else log.content
                }
                for log in logs
            ],
            "total": len(logs)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=ErrorMessages.GENERIC_ERROR)

@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {"status": "healthy", "version": "1.0.0"}